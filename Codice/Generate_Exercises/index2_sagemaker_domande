import { MongoClient } from 'mongodb';
import { InvokeEndpointCommand, SageMakerRuntimeClient } from "@aws-sdk/client-sagemaker-runtime";

const mongo = new MongoClient(process.env.MONGO_URI);
const sagemaker = new SageMakerRuntimeClient({ region: "us-east-1" });

export const handler = async (event) => {
  const { talk_id, transcript } = JSON.parse(event.body || '{}');

  if (!transcript || transcript.length < 20) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: "Transcript troppo corto o mancante." })
    };
  }

  try {
    await mongo.connect();
    const db = mongo.db('tedxlanguage');
    const collection = db.collection('exercises');

    // Step 1: Genera domande da transcript (QG)
    const questionList = await generateQuestions(transcript);
    if (!questionList.length) throw new Error("Nessuna domanda generata");

    const results = [];

    // Step 2: Per ogni domanda genera esercizio fill-in-the-blank
    for (const question of questionList) {
      const masked = maskQuestion(question);
      const suggestions = await getFillMaskOptions(masked);

      const doc = {
        talk_id,
        original_question: question,
        masked_question: masked,
        options: suggestions,
        created_at: new Date()
      };

      const res = await collection.insertOne(doc);
      results.push({ exercise_id: res.insertedId, masked_question: masked, options: suggestions });
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Esercizi generati",
        count: results.length,
        exercises: results
      })
    };

  } catch (err) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: err.message })
    };
  } finally {
    await mongo.close();
  }
};

async function generateQuestions(transcript) {
  const payload = {
    inputs: transcript,
    parameters: {
      max_length: 128,
      do_sample: true,
      temperature: 0.8,
      top_k: 50,
      top_p: 0.95
    }
  };

  const command = new InvokeEndpointCommand({
    EndpointName: 'QG-E2E',
    ContentType: 'application/json',
    Body: Buffer.from(JSON.stringify(payload))
  });

  const response = await sagemaker.send(command);
  const body = Buffer.from(response.Body).toString();
  const parsed = JSON.parse(body);

  if (!Array.isArray(parsed) || !parsed[0]?.generated_text) {
    throw new Error("Risposta SageMaker non valida");
  }

  const generatedText = parsed[0].generated_text;

  // ðŸ” Separa le frasi usando "." o "<sep>" (modificabile)
  return generatedText
    .split(/[.?!]/) // puoi sostituire con .split('<sep>') se usi un altro modello
    .map(q => q.trim())
    .filter(q => q.length > 10);
}



function maskQuestion(question) {
  const parts = question.split(' ');
  const index = parts.findIndex(w => w.length > 4);
  if (index >= 0) parts[index] = '[MASK]';
  return parts.join(' ');
}

async function getFillMaskOptions(maskedQuestion) {
  const command = new InvokeEndpointCommand({
    EndpointName: 'NLP-Exercise-Generator',
    ContentType: 'application/json',
    Body: Buffer.from(JSON.stringify({ inputs: maskedQuestion }))
  });

  const response = await sagemaker.send(command);
  const body = Buffer.from(response.Body).toString();
  const predictions = JSON.parse(body);

  return predictions.map(p => {
    const completed = p.sequence;
    // Estrai la parola al posto del [MASK]
    const words = maskedQuestion.split(' ');
    const maskIndex = words.findIndex(w => w === '[MASK]');
    const completedWords = completed.split(' ');

    return completedWords[maskIndex] || completedWords[0]; // fallback
  });
}
